p/a *0x80008a7c
set *0x80008a7c = 0


init.c:448
thread.c:533
thread.c:451

thread.c:564

thread.c:118 !!! -> ICI

thread.c:121
init.c:348

3 attaques ne fonctionnent plus -> 1,5,9
Notre fix est super violent, il faut reprogrammer le FPGA à chaque fois que y'a une attaque ...
Peut être mieux si on ajoute une condition et que quand y'a un ret avec une adresse pas encodée 
on saute à un endroit precis et pas dans le trou du cul du pc...


prepare_multithreading () at /workdir/zephyr/kernel/init.c:324 -> le fait 1 fois
init.c:324
thread.c:533
0x8000491c -> sw ra,28(sp)
-> somewhere here
0x80004920 -> sw s0,24(sp)  something happened
0x80004930
0x8000493c
wait_q.h:49 // 0x8000495c
thread.c:550
init.c:347
init.c:352
soc_irq.S:29


0x800034c8
0x800034cc
0x800034f0
0x800034f4

0x80002d90 -> to see result = 0x80007ca8
0x80002f0c    sw s4,8(sp) - here  - 0x80007cc8
0000000 10100 00010 010 01000 0100011
         rs2   rs1       imm    
0x80002f20

 00010 000 01111 0101011


switch_to_main_thread
z_swap_unlocked
z_riscv_switch
z_riscv_thread_start
soc_irq.S:29


0x800001c4 -> problème ?????????? 1ère fois ok

isr.S:464
timer_isr
irq_done
check_reschedule
-----> ici
sched.c:1112
-----> ici
reschedule
z_riscv_thread_start (again ?)


0x800001e4
"user"
0x80000abc

    branch
input   fu_data_i         decoded_instr_i
  ex
input   fu_data_i         decoded_instr_i
ariane
logic   fu_data_id_ex     issue_entry_issue_ex
  issue
output  fu_data_o         decoded_instr_o
    issue_read_operands

    d flipflop
input                      issue_entry_id_issue




Custom instr
opcode : 0001011
rd     : 00101      t0 - x5
imm    : 0
total  : 00000000000000000000 00101 0001011
total  : 0000 0000 0000 0000 0000 0010 1000 1011
total  : 0x0000028b

total  : 0x0000058b
         0000 0000 0000 0000 0000 01011 0001011

PROBLEME NOUVELLE INSTRUCTION -> CRASH QUAND APPEL
PROBLEME DE CRASH DANS RTOS MAIS RESOLU AVEC B *0x800001c4 ???


_____
0x800027a0

0x80004030 -> sb avec a3

~~ meurs à chaque printf (même fonctions printf et printk)
ça marche en step by step 
-> fini dans le fatal.c OU isr.S?
"Save caller-saved registers on current thread stack."

lw @1
jalr @1
-> ça devrait marcher

lw @a1 
autre instr 
autre lw??? -> met à 0
jalr @1  -> on saute pas


_____________

0x80007610 <- sortie du fprintf
-> on ne sort pas du fprintf, on l'atteint pas

-> l'existence d'un fprintf fait crash tout court, même sans variables
printk fonctionne mais pas fprintf?
